#!/usr/bin/env python

#Created by Bruno de Medeiros October 2017
#This script takes as input a *.alleles.loci file generated by ipyRAD
#and outputs to several nexus files, one per locus
#Optionally, it adds populations to species names, if a CSV file
#with columns 'sample' and 'population' are provided
#The goal is to use it as input file to STAR BEAST

import StringIO, argparse, os, pandas
from collections import Counter
import random
from Bio import AlignIO
from Bio.Alphabet.IUPAC import IUPACAmbiguousDNA

#this function parses population files to a dictionary
def parse_pop_file(inpath, ipyrad):
    samp2pop = dict()  
    if ipyrad:
        with open(inpath, 'r') as popfile:
            for line in popfile:
                line = line.split('#')[0]
                try:
                    sample, pop =  line.split()
                except:
                    break
                if not sample or not pop:
                    break
                else:
                    samp2pop[sample] = pop
    else:
        pop_table = pandas.read_csv(inpath)
        for i, row in pop_table.iterrows():
            samp2pop[row['sample']] = row['population']
    return samp2pop
            
def parse_alleles_file(inpath, num_spns):
    matrix_list = []
    with open(inpath, 'r') as allfile:
        temp = ''
        for line in allfile:
            if '//' not in line and line.lstrip('\n'):
                temp = temp + line
            elif not line.rstrip('\n '): #sometimes there are blank lines...
                continue
            else:
                symbol_counter = Counter(line)
                if num_spns & (symbol_counter['*'] + symbol_counter['-']) == num_spns: 
                    nchar = int(len(temp.split('\n')[0].split()[-1]))
                    ntaxa = int(temp.count('\n'))
                    temp = str(ntaxa) + '\t' + str(nchar) + '\n' + temp
                    phylip = StringIO.StringIO(temp)
                    matrix_list.append(AlignIO.read(phylip, "phylip-relaxed", alphabet=IUPACAmbiguousDNA()))
                    phylip.close()
                temp = '' #whether or not passes minspns filter, zero temp again
    return matrix_list
                
def add_pop_name(alignment, samp2pop):
    for record in alignment:
        record.id = record.id + '_' + samp2pop[record.id.split('_')[0]]
    return None
        
    


if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument('input', help = 'path to input file,*.unlinked_snps generated by pyRAD')
    parser.add_argument('-p','--pop-file', help = "path to file with population information, if population name is to be appended. It must be in csv format and contain a column named 'sample' and another named 'population'")
    parser.add_argument('-i','--ipyrad', help = "use this flag to use an ipyrad population file, instead of the standard format", action= "store_true")
    parser.add_argument('-s','--subsample', help = "number of loci to randomly subsample. If ommited, all loci are kept", type = int, default = 0)
    parser.add_argument('-m','--num-snps', help = "number of SNPs to keep a locus. If ommited, all loci are kept", type = int, default = 0)
    args = parser.parse_args()
    #args = parser.parse_args(['-i','-p','/Volumes/Genomics/Odyssey/2017/RAD_phylogeography/STARBEAST/plant_pops.txt','/Volumes/Genomics/Odyssey/2017/RAD_phylogeography/STARBEAST/plants-cov12-pop1.alleles.loci'])
    
    outname = os.path.basename(args.input).split('.')[0]
    
    #get alignments and add population names
    alignments = parse_alleles_file(args.input, args.num_snps)
    
    if args.pop_file:
        samp2pop = parse_pop_file(args.pop_file, args.ipyrad)
        for alignment in alignments:
            add_pop_name(alignment, samp2pop) 
        
    #subsample loci
    if args.subsample > 0:
        if args.subsample < len(alignments):
            alignments = random.sample(alignments,args.subsample)
        else:
            raise Exception('Number to subsample must be smaller than number of loci available!')
        
    
    #now make output
    try:
        os.makedirs(outname)
    except:
        pass
    
    for i, alignment in enumerate(alignments):
        AlignIO.write(alignment, outname + '/' + outname + '_' + str(i) + ".nex", "nexus")